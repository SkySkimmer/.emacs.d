#+STARTUP: overview

* Licensing
Most of this stuff is either too trivial for copyright to apply or
copied from other people. Anything that's mine is licensed [[/LICENSE][GPL3]] or
later.

* About
This is Gaëtan Gilbert aka the SkySkimmer's Emacs configuration. It is
formatted as an org file and is best viewed in Emacs.

It uses the [[https://github.com/raxod502/straight.el][straight.el]] package manager with [[https://github.com/jwiegley/use-package][use-package]] integration.
Look in the [[Package management]] section for information about using the
builtin package.el instead (essentially you need to bootstrap
=use-package=).

* Lexical binding
This needs to be on the very first line, thus =:padline no=
#+BEGIN_SRC emacs-lisp :padline no
;;; -*- lexical-binding: t; -*-
#+END_SRC

* Secrets
#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/secrets" nil nil)
#+END_SRC

* Security (TLS)
Apparently emacs does silly things with tls.
#+BEGIN_SRC emacs-lisp
(require 'tls)
(require 'gnutls)
(setq tls-checktrust t)
(setq gnutls-verify-error t)
#+END_SRC

* Package management
We use the straight package manager
(https://github.com/raxod502/straight.el).

** Recipes
We put recipe overrides at the beginning to avoid any chance of some
package dependency being acquired before the override.
#+BEGIN_SRC emacs-lisp
(defvar straight-recipe-overrides)
(let ((my/recipes nil))
  (push '(caml
          :type git
          :files ("emacs/*.el")
          :host github
          :repo "ocaml/ocaml"
          :branch "trunk")
        my/recipes)
  (setq straight-recipe-overrides
        (cons (cons nil my/recipes) nil)))
#+END_SRC

** Install straight
Bootstrap is using a git submodule instead of downloading some random
elisp.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar straight-check-for-modifications)
  (setq  straight-check-for-modifications 'never)

  (defvar bootstrap-version)
  (unless (featurep 'straight)
    (let ((bootstrap-file (concat user-emacs-directory "straight/repos/straight.el/bootstrap.el"))
          (bootstrap-version 1))
      (unless (file-exists-p bootstrap-file)
        (error "Straight bootstrapper not present: %s" bootstrap-file))
      (load bootstrap-file))))
(require 'straight)
(setq straight-vc-git-auto-fast-forward nil)
#+END_SRC

** straight+
Like =straight-fetch= functions but use =fetch --all= instead of
fetching some specific remote.
#+BEGIN_SRC emacs-lisp
(cl-defun straight-vc-git-fetch (recipe)
  "Using straight.el-style RECIPE, fetch all remotes."
  (while t
    (and (straight-vc-git--ensure-remotes recipe)
         (straight--get-call "git" "fetch" "--all")
         (cl-return-from straight-vc-git-fetch t))))

(defun straight-vc-fetch (recipe)
  "Pull from all remotes for straight.el-style RECIPE.

This method sets `straight--default-directory' to the local
repository directory and delegates to the relevant
`straight-vc-TYPE-pull-from-remote' method, where TYPE is the
`:type' specified in RECIPE."
  (straight--with-plist recipe
      (local-repo type)
    (let ((straight--default-directory (straight--dir "repos" local-repo)))
      (straight-vc 'fetch type recipe))))

(defun straight-fetch-package (package &optional ignored)
  "Try to fetch a PACKAGE from all remotes.
PACKAGE is a string naming a package. Interactively, select
PACKAGE from the known packages in the current Emacs session
using `completing-read'."
  (interactive (list (straight--select-package "Fetch package" nil 'install)))
  (let ((recipe (gethash package straight--recipe-cache)))
    (straight-vc-fetch recipe)))

(defun straight-fetch-all (&optional ignored predicate)
  "Try to fetch all packages (with fetch --all).

Return a list of recipes for packages that were not successfully
pulled. If multiple packages come from the same local repository,
only one is pulled.

PREDICATE, if provided, filters the packages that are normalized.
It is called with the package name as a string, and should return
non-nil if the package should actually be normalized."
  (interactive)
  (straight--map-existing-repos-interactively
   (lambda (package)
     (straight-fetch-package package))
   predicate))
#+END_SRC

** use-package, bind-key and diminish
use-package is nice for organisation.
I'm considering enabling the always-defer option.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (straight-use-package 'use-package)
  (defvar use-package-always-ensure)
  (defvar use-package-verbose)
  (setq use-package-always-ensure nil
        use-package-verbose t
        straight-use-package-by-default t)
  ;; (setq use-package-always-defer t)
  )
(require 'use-package)

(use-package bind-key)
(use-package diminish)
#+END_SRC

** package.el system (disabled)
Note that package-enable-at-startup is set to nil in the init.el as
well as straight's bootstrap.
#+BEGIN_SRC emacs-lisp :tangle no
(require 'tls)
(require 'gnutls)
(setq tls-checktrust t)
(setq gnutls-verify-error t)

(require 'package)
(setq package-enable-at-startup nil)
(setq package-archives (list '("gnu" . "https://elpa.gnu.org/packages/")))
(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/"))
(package-initialize)

;; Bootstrap `use-package'
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
        (package-install 'use-package))
(require 'use-package)
(setq use-package-always-ensure t)
#+END_SRC

* Backups
#+BEGIN_SRC emacs-lisp
  (setq
   backup-directory-alist '(("." . "~/.emacs.d/backups"))
   delete-old-versions -1
   version-control t
   vc-make-backup-files t
   backup-by-copying t)
#+END_SRC
This bit is for the # anti-crash files
#+BEGIN_SRC emacs-lisp
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC

* History
This is mostly minibuffer history. Not sure it works with counsel, we shall see.
#+BEGIN_SRC emacs-lisp
  (require 'savehist)
  (savehist-mode 1)
  (setq savehist-file "~/.emacs.d/savehist")
  (setq history-length t)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history t)
  (setq savehist-additional-variables
        '(kill-ring
          search-ring
          regexp-search-ring))
#+END_SRC

* interface tweaks
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(fset 'yes-or-no-p 'y-or-n-p)
(global-set-key (kbd "<f5>") 'revert-buffer)
(defalias 'list-buffers 'ibuffer)
(show-paren-mode 1)
(add-to-list 'default-frame-alist '(fullscreen . maximized))
(delete-selection-mode 1); delete selected region on typing
(line-number-mode 1)
(column-number-mode 1)
(blink-cursor-mode 0)
(setq-default indent-tabs-mode nil)
(defvar apropos-do-all)
(defvar recentf-max-saved-items)
(defvar compilation-scroll-output)
(defvar show-paren-delay)
(defvar custom-search-field)
(setq
 inhibit-startup-message t
 require-final-newline t
 diff-switches "-u"; unified diffs
 sentence-end-double-space nil
 scroll-error-top-bottom t
 read-quoted-char-radix 16
 apropos-do-all t
 browse-url-browser-function 'eww-browse-url
 recentf-max-saved-items 100
 recenter-positions '(top middle bottom)
 use-dialog-box nil
 disabled-command-function nil
 compilation-scroll-output 'first-error
 enable-recursive-minibuffers t
 minibuffer-message-timeout 0.5
; print-circle t
 window-combination-resize t
 mouse-yank-at-point t
 frame-resize-pixelwise t
 shell-file-name "/bin/bash"
 vc-follow-symlinks t
 find-file-visit-truename t
 show-paren-delay 0
 custom-search-field nil)
(minibuffer-depth-indicate-mode t)

;; thanks http://pragmaticemacs.com/emacs/cycle-spacing/
(global-set-key (kbd "M-SPC") 'cycle-spacing)

(global-unset-key (kbd "<insert>"))
#+END_SRC

** Dash fontlock
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'dash
  (dash-enable-font-lock))
#+END_SRC

** highlight current line
   #+BEGIN_SRC emacs-lisp
     (require 'hl-line)
     (global-hl-line-mode t)
     (set-face-background hl-line-face "LightCyan2")
   #+END_SRC

** Clipboard integration
   #+BEGIN_SRC emacs-lisp
     (setq select-enable-clipboard t)
     ;; Treat clipboard input as UTF-8 string first; compound text next, etc.
     (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
     (setq save-interprogram-paste-before-kill t)
     (setq kill-do-not-save-duplicates t)
   #+END_SRC

* my/set
#+BEGIN_SRC emacs-lisp
(defun replace-string-in-form (form orig new)
  "Replace all appearances of ORIG in strings appearing in FORM
by NEW."
  (pcase form
    ((pred consp)
     (cons (replace-string-in-form (car form) orig new)
           (replace-string-in-form (cdr form) orig new)))
    ((pred stringp)
     (if (string-match orig form)
         (replace-match new t nil form)
       form))
    (_ form)))

(defun my/set (symbol newval)
  "`interactive' wrapping around `set', which see."
  (interactive
   (let* ((symbol (car (eval (replace-string-in-form
                     (cadr (interactive-form #'describe-variable))
                     "Describe variable"
                     "Variable") t)))
          (oldval (symbol-value symbol))
          (foo (message "%s" oldval))
          (newval (eval (read-minibuffer "Lisp expression: "
                                         (when oldval (format "'%S" oldval))))))
     (list symbol newval)))

  (set symbol newval))
#+END_SRC

* Compile mode
#+BEGIN_SRC emacs-lisp
(defalias 'make #'compile)
#+END_SRC

* Dired
TODO use-package?
#+BEGIN_SRC emacs-lisp
(require 'dired)
(require 'dired-x)
(add-hook 'dired-mode-hook #'dired-omit-mode)
(setq
 dired-ls-F-marks-symlinks t
 dired-listing-switches "-alF --group-directories-first"
 dired-omit-files nil
 dired-omit-size-limit nil)
#+END_SRC

* Scroll half screens
   #+BEGIN_SRC emacs-lisp
     (setq
      mouse-wheel-scroll-amount '(1 ((shift) . 1))
      mouse-wheel-progressive-speed nil)

     (defun window-half-height ()
       (max 1 (/ (1- (window-height (selected-window))) 2)))

     (defun reset-next-screen-context-lines ()
       "Set `next-screen-context-lines' to screen height / 2"
       (setq next-screen-context-lines (window-half-height)))

     (defadvice scroll-up-command (before scroll-up-half-screen activate)
       "Set `next-screen-context-lines' to screen height / 2"
       (reset-next-screen-context-lines))
     (defadvice scroll-down-command (before scroll-down-half-screen activate)
       "Set `next-screen-context-lines' to screen height / 2"
       (reset-next-screen-context-lines))
   #+END_SRC

* Smarter move-beginning-of-line
Indent aware line beginning
#+BEGIN_SRC emacs-lisp
(defun my/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

   Move point to the beginning of the line.
   If point is already there, move to the first non-whitespace character on this line.
   Effectively toggle between the first non-whitespace character and
   the beginning of the line.

   If ARG is not nil or 1, move forward ARG - 1 lines first.  If
   point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (move-beginning-of-line 1)
    (when (= orig-point (point))
      (back-to-indentation))))

;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
                'my/smarter-move-beginning-of-line)
#+END_SRC

* Frame title
Note that the "〖〗" characters have no space before/after them.

Print default directory according to major mode based on [[https://github.com/jbms/jmswm/blob/19f11ff1f081c07468b149998d851a2b7b1d54cd/config/emacs.example.el][jbms@github/jmswm]].
#+BEGIN_SRC emacs-lisp
(defconst major-modes-with-meaningful-directory
  '(magit-log-mode
    magit-status-mode
    dired-mode
    eshell-mode)
  "Major modes where the directory is interesting
even if there is no associated file.")

(defun default-directory-meaningful-p ()
  "Figure out if the default directory of the current buffer
  is meaningful according to `major-modes-with-meaningful-directory'"
  (memq major-mode major-modes-with-meaningful-directory))

(defun help-what-about ()
  "Returns nil if called in non help-mode derived buffer.
  Otherwise guesses what the help buffer is about.
  If it succeeds the guess is returned as a string. Otherwise returns nil.

  Heuristics:
  If the buffer starts with a known symbol (i.e. in `obarray') that's our result.
  This may return the wrong thing: imagine a mode where `t t' runs `foo', we will
  think `describe-key' is talking about the symbol `t' alone.
  If someone defines `Enabled' we will be similarly confused after `describe-mode', etc."
  (if (derived-mode-p 'help-mode)
      (let ((described-thing
             ;; (current-word t ...) protects us against things
             ;; like describe-char which start with spaces
             (save-excursion (progn (goto-char (point-min)) (current-word t nil)))))
        (if (or
             (intern-soft described-thing)
             ;; Special case since  (intern-soft "nil") ==> nil
             (string-equal described-thing "nil"))
            described-thing
          nil))))

(defun frame-title-mode-bonus ()
  "If current buffer is associated with a file, return that file's name.
  Otherwise if `default-directory-meaningful-p' return the default directory.
  In both cases paths are bracketed with \"〖〗\" and processed by `abbreviate-file-name'.
  If no path is meaningful return a space."
  (if (buffer-file-name)
      (format "〖%s〗" (abbreviate-file-name (buffer-file-name)))
    (if (default-directory-meaningful-p)
        (format "〖%s〗" (abbreviate-file-name default-directory))
      (if-let ((described-thing (help-what-about)))
          (format "〖%s〗" described-thing)
        " "))))

(setq frame-title-format
      '((:eval (if (and (buffer-modified-p) (not buffer-read-only)) "(!) " ""))
        "%b"
        (:eval (frame-title-mode-bonus))
        "— Emacs"))
#+END_SRC

* Emacs source
#+BEGIN_SRC emacs-lisp
(defvar find-function-C-source-directory)
(setq find-function-C-source-directory "/home/gaetan/dev/emacs/src/")
#+END_SRC

* elisp
** eldoc
#+BEGIN_SRC emacs-lisp
(setq eldoc-idle-delay 0)

;; considering (from radian)
;; Always truncate ElDoc messages to one line. This prevents the echo
;; area from resizing itself unexpectedly when point is on a variable
;; with a multiline docstring.
;;(setq eldoc-echo-area-use-multiline-p nil)
#+END_SRC

** find-symbol-at-point
#+BEGIN_SRC emacs-lisp
(defun find-function-at-point ()
  "Call `find-function' for symbol at point."
  (interactive)
  (find-function (symbol-at-point)))

(defun find-variable-at-point ()
  "Call `find-variable' for symbol at point."
  (interactive)
  (let ((sym (symbol-at-point)))
    (find-variable sym)))

(bind-key "C-c f" #'find-function-at-point emacs-lisp-mode-map)
(bind-key "C-c v" #'find-variable-at-point emacs-lisp-mode-map)
#+END_SRC


** expand macro
#+BEGIN_SRC emacs-lisp
(use-package elisp-mode
  :straight nil
  :bind (("s-e" . emacs-lisp-macroexpand)))
#+END_SRC

* Rainbow mode
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :commands (rainbow-mode))
#+END_SRC

* Avy and linum configuration
Replace =goto-line= with =avy-goto-line= with temporary enabling of linum mode.
Linum mode is also made to look nicer.

Note that jumping to a line by its number is still possible with avy.

** Fist make linum pretty
#+BEGIN_SRC emacs-lisp
(require 'linum)

(set-face-attribute 'linum nil
                    :background (face-attribute 'default :background)
                    :foreground (face-attribute 'font-lock-comment-face :foreground))

(defface linum-current-line-face
  `((t :background "gray30" :foreground "gold"))
  "Face for the currently active Line number"
  :group 'skyskimmer-faces)

(defvar my-linum-current-line-number 0)

(defun my/linum-format-string ()
  (let ((w (length (number-to-string
                                (count-lines (point-min) (point-max))))))
                (concat " %" (number-to-string w) "d ")))

(defun my-linum-format (line-number)
  (propertize (format (my/linum-format-string) line-number) 'face
              (if (eq line-number my-linum-current-line-number)
                  'linum-current-line-face
                'linum)))

(setq linum-format 'my-linum-format)

(defadvice linum-update (around my-linum-update activate)
  (let ((my-linum-current-line-number (line-number-at-pos)))
    ad-do-it))
#+END_SRC

** Then setup avy
#+BEGIN_SRC emacs-lisp
;; based on joshwnj and magnars https://gist.github.com/joshwnj/3292750
(defun avy-goto-line-with-feedback ()
  "Show line numbers temporarily, while prompting for the line number input"
  (interactive)
  (let ((line-numbers-off-p (not linum-mode)))
    (unwind-protect
        (progn (when line-numbers-off-p
                 (linum-mode 1))
               (call-interactively 'avy-goto-line))
      (when line-numbers-off-p
        (linum-mode -1)))))

(use-package avy
  :bind (([remap goto-line] . avy-goto-line-with-feedback))
  :commands (avy-goto-line)
  :config
  (setq avy-style 'de-bruijn))
#+END_SRC

* Save place in files
#+BEGIN_SRC emacs-lisp
(require 'saveplace)
(setq save-place-file "~/.emacs.d/saveplace")
(save-place-mode t)
#+END_SRC

* Unicode
#+BEGIN_SRC emacs-lisp
(set-charset-priority 'unicode)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix))
#+END_SRC

* Immortal *scratch*
#+BEGIN_SRC emacs-lisp
(defadvice kill-buffer (around kill-buffer-immortal-scratch activate)
  (let ((buffer-to-kill (ad-get-arg 0)))
    (if (equal buffer-to-kill "*scratch*")
        (bury-buffer buffer-to-kill)
      ad-do-it)))
#+END_SRC

* Prettify symbols
#+BEGIN_SRC emacs-lisp
  (defun prettify-lisp-additions ()
    (push '("lambda" . ?λ) prettify-symbols-alist))

  (add-hook 'emacs-lisp-mode-hook
            'prettify-lisp-additions)

  (defun prettify-ocaml-additions ()
    (push '("->" . ?→) prettify-symbols-alist))
  (add-hook 'tuareg-mode-hook
            'prettify-ocaml-additions)

  (global-prettify-symbols-mode 1)
#+END_SRC

* try
#+BEGIN_SRC emacs-lisp
;(use-package try)
#+END_SRC

* Keystroke help and which-key
Display keystrokes in the echo area immediately, not after one second.
We can't set the delay to zero because somebody thought it would be a
good idea to have that value suppress keystroke display entirely.

Taken from radian.
#+BEGIN_SRC emacs-lisp
(cl-float-limits)
(setq echo-keystrokes cl-float-epsilon)
#+END_SRC

When I start typing, display functions associated with possible
following keys.
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :config
  (which-key-mode))
#+END_SRC

* org mode
#+BEGIN_SRC emacs-lisp
(require 'org)
(setq
 org-catch-invisible-edits 'error
 org-return-follows-link t
 org-startup-indented t
 org-src-preserve-indentation t
 org-src-fontify-natively t
 org-src-tab-acts-natively t
 org-ellipsis " ▼"
 org-cycle-separator-lines 1)

(defvar org-latex-packages-alist)
(defvar org-latex-listings)
(defvar org-latex-pdf-process)
(defvar org-latex-minted-options)

;; Setup minted syntax highlighting
(add-to-list 'org-latex-packages-alist '("" "minted"))
(setq org-latex-listings 'minted)

;; Add the shell-escape flag
(setq org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        ;; "bibtex %b"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

;; Sample minted options.
(setq org-latex-minted-options
      '(("frame" "lines")
        ("fontsize" "\\scriptsize")
        ("xleftmargin" "\\parindent")
        ("linenos" "")))

(use-package org-bullets
  :commands org-bullets-mode
  :init
  (defun my/org-hook ()
    (org-bullets-mode 1)
    (auto-fill-mode 1))
  (add-hook 'org-mode-hook #'my/org-hook))
#+END_SRC

* Window switching (Ace window)
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :bind (([remap other-window] . ace-window))
  :config
  (setq aw-scope 'frame))
#+END_SRC

* Swiper/counsel/ivy
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :bind
  (("M-y" . counsel-yank-pop)
   :map ivy-minibuffer-map
   ("M-y" . ivy-next-line)))

(use-package ivy
  :diminish (ivy-mode)
  :demand t
  :bind (("C-x b" . ivy-switch-buffer))
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t)
  (setq ivy-display-style 'fancy)
  ;; this makes autocompletion for git refs in magit worse
  (setcdr (assq t ivy-sort-functions-alist) nil))

(use-package swiper
  :bind (("C-s" . swiper)
         ("C-S-s" . counsel-imenu)
         ("C-r" . swiper)
         ("C-c C-r" . ivy-resume)
         ("M-x" . counsel-M-x)
         ("C-x C-f" . counsel-find-file)
         ("C-x 8 RET" . counsel-unicode-char))
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t)
  (setq ivy-display-style 'fancy)
  (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)

  (defun my/update-counsel-find-file-ignore-regexp ()
    "Reset `counsel-find-file-ignore-regexp' using `completion-ignored-extensions'"
    (let* ((exts (mapcar (lambda (x) `(: ,x eol)) completion-ignored-extensions))
       (exts `(or ,@exts)))
      (setq counsel-find-file-ignore-regexp (rx-to-string exts t))))

  (my/update-counsel-find-file-ignore-regexp))
#+END_SRC

* Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :defer 5
  :diminish " ℂ"
  :config
  (global-company-mode)
  (setq company-idle-delay 0.3
        company-minimum-prefix-length 2))

(use-package company-flx
  :defer 5
  :config
  (company-flx-mode 1))
#+END_SRC

* Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :defer 5
  :config
  (global-flycheck-mode)
  (setq-default flycheck-disabled-checkers '(rst-sphinx emacs-lisp-checkdoc coq
                                                        tex-chktex tex-lacheck))
  (setq flycheck-tex-chktex-executable "~/bin/chktex-wrap.sh"))
#+END_SRC

* Magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :config
  (setq
   magit-diff-refine-hunk 'all
   magit-log-margin '(t "%Y-%m-%d %H:%M" magit-log-margin-width t 18)
   magit-diff-highlight-indentation '((".*" . tabs))
   magit-branch-rename-push-target 'local-only
   magit-section-initial-visibility-alist '(([unpushed status] . show)
                                            ([unpulled status] . show)))
  (add-to-list 'magit-log-arguments "--follow")

  (magit-define-popup-action 'magit-merge-popup ?u
    "Merge upstream"
    (lambda ()
      (interactive)
      (magit-merge "@{upstream}" '("--ff-only"))))

  (defun my/show-commit ()
    "Calls `magit-show-commit' with negated prefix argument."
    (interactive)
    (let ((current-prefix-arg (not current-prefix-arg)))
      (call-interactively #'magit-show-commit)))
  :bind (("C-x g" . magit-status)
         ("C-x G" . my/show-commit)))

(use-package diff-hl
  :after magit
  :config
  (add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh)
  (global-diff-hl-mode t))
#+END_SRC

* OCaml
ocp-indent is installed via opam.

NB: tuareg depends on caml.el which comes from the ocaml repo. May
take time to download.
If this is a problem one could download the tarball from melpa (which
has only the .el files) and use it to make a fake git repository.
#+BEGIN_SRC emacs-lisp
(use-package tuareg
  :defines (tuareg-mode-hook)
  :mode (("\\.ml[4iplg]?\\'" . tuareg-mode)
         ("[./]opam_?\\'" . tuareg-opam-mode)
         ("\\(?:\\`\\|/\\)jbuild\\'" . tuareg-jbuild-mode)
         ("\\.eliomi?\\'" . tuareg-mode))
  :init
  (defun tuareg-reset-indent ()
    "Reset comment style for tuareg mode"
    (setq-local comment-style 'indent))
  (add-hook 'tuareg-mode-hook #'tuareg-reset-indent)

  (push ".ml.d" completion-ignored-extensions)
  (push ".mli.d" completion-ignored-extensions))

(use-package ocp-indent
  :straight nil ; not handled by straight
  :load-path "/home/gaetan/.opam/4.07.1/share/emacs/site-lisp"
  :after tuareg
  :config (setq ocp-indent-untabify t))

(use-package merlin
  :diminish
  :defines (merlin-locate-preference)
  :commands (merlin-mode merlin-locate)
  :bind (:map merlin-mode-map ([remap merlin-locate] . my/merlin-locate))
  :init
  (add-hook 'tuareg-mode-hook #'merlin-mode)

  (defun my/invert-merlin-locate-preference ()
    (cl-case merlin-locate-preference
      ('ml 'mli)
      ('mli 'ml)))

  (defun my/merlin-locate (&optional arg)
    "Locate the identifier under point.

With prefix argument, invert `merlin-locate-preference'."
    (interactive "P")
    (let ((merlin-locate-preference
           (if arg (my/invert-merlin-locate-preference) merlin-locate-preference)))
      (merlin-locate)))

  :config
  ;; Disable Merlin's own error checking, we use flycheck
  (setq merlin-error-after-save nil))

(use-package flycheck-ocaml
  :after merlin
  :config
  ;; Enable Flycheck checker
  (flycheck-ocaml-setup))

(use-package dune
  :straight (dune :type git :host github :repo "ocaml/dune"
                  :files ("editor-integration/emacs/dune.el")))
#+END_SRC

* Coq dev
#+BEGIN_SRC emacs-lisp
(require 'coqdev "~/.emacs.d/coqdev.el")

(defun debug-coq-sender (input)
  (insert input)
  (comint-send-input))
(defvar ocamldebug-command-name)
(defun debug-coq (coq)
  "Call ocamldebug for coqtop with correct arguments."
  (interactive (let ((f (read-file-name
                         "Coq executable: " nil nil t "coqtop.byte"
                         ;; allow directories for navigation
                         (lambda (f) (string-match (rx (or ".byte" "/") string-end) f)))))
                 (list f)))
  (let ((ocamldebug-command-name "../dev/ocamldebug-coq"))
    (message "coq is %s" coq)
    (when (not (string= (file-name-extension coq) "byte"))
      (error "Not a byte executable %s" coq))
    (ocamldebug coq)
    (debug-coq-sender "cd ../dev")
    (debug-coq-sender "source db")
    (debug-coq-sender "cd ..")))

(defun my/coqbin (dir)
  "Set COQBIN environment variable"
  (interactive "DDirectory: ")
  (setenv "COQBIN" dir))

(defun my/coqargs ()
  (interactive)
  (add-file-local-variable-prop-line 'coq-prog-args '("")))

(defun my/git-overlay-fix ()
  "Fix .git/config for Coq overlays"
  (interactive)
  (re-search-forward "https://github.com/.*/")
  (replace-match "git@github.com:SkySkimmer/"))
#+END_SRC

* Melt
Mode for editing Melt (.mlt) files. Melt is a tool to generate latex
from OCaml.
#+BEGIN_SRC emacs-lisp
(use-package melt-mode
  :straight nil
  :load-path "/home/gaetan/dev/ocaml-melt/")
#+END_SRC

* Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :mode  (("\\.markdown\\'" . gfm-mode)
          ("\\.md\\'" . gfm-mode))
  :init (add-hook 'markdown-mode-hook #'visual-line-mode))
#+END_SRC

* Whitespace
#+BEGIN_SRC emacs-lisp
(setq show-trailing-whitespace t)
#+END_SRC

** ws-butler (unobtrusive whitespace remover)
#+BEGIN_SRC emacs-lisp
(use-package ws-butler
  :diminish ws-butler-mode
  :commands (ws-butler-mode)
  :init
  (add-hook 'prog-mode-hook #'ws-butler-mode)
  (add-hook 'org-mode-hook #'ws-butler-mode)
  (add-hook 'text-mode-hook #'ws-butler-mode)
  (add-hook 'proof-mode-hook #'ws-butler-mode)
  (add-hook 'bibtex-mode-hook #'ws-butler-mode)
  :config
  (setq ws-butler-convert-leading-tabs-or-spaces t))
#+END_SRC

* nv-delete-back
#+BEGIN_SRC emacs-lisp
(use-package nv-delete-back
  :bind (("C-<backspace>" . nv-delete-back-all)
         ("M-<backspace>" . nv-delete-back)))
#+END_SRC

* Semantic region
#+BEGIN_SRC emacs-lisp
;; expand the marked region in semantic increments (negative prefix to reduce region)
(use-package expand-region
  :bind (("C-=" . er/expand-region)))
#+END_SRC

* Undo tree
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :diminish undo-tree-mode
  :config
  (global-undo-tree-mode)
  (setq undo-tree-visualizer-diff t
        undo-tree-visualizer-timestamps t
        undo-tree-enable-undo-in-region nil))
#+END_SRC

* Proof General
TODO recipe
#+BEGIN_SRC emacs-lisp
(use-package proof-site
  :straight proof-general

  :defines (coq-mode-map
            proof-prog-name-ask
            proof-follow-mode
            proof-sticky-errors
            proof-splash-seen)

  :init
  (push ".v.d" completion-ignored-extensions)

  :config
  (setq
   proof-prog-name-ask t
   proof-follow-mode 'followdown
   proof-sticky-errors t
   proof-splash-seen t)

  (defun my/coq-test-option (string)
    "Ask Coq if option STRING is set."
    (let ((res (company-coq-ask-prover (concat "Test " string "."))))
      (cond
       ((string-match-p (rx "off" eol) res) nil)
       ((string-match-p (rx "on" eol) res) t)
       (t (error "Bad result in coq-test-option: %s" res)))))

  (defun my/coq-toggle-option (string)
    "Toggle option STRING according to the result of `my/coq-test-option'."
    (interactive "M")
    (let ((string (if (my/coq-test-option string)
                      (concat "Unset " string ".")
                    (concat "Set " string "."))))
      (proof-shell-invisible-command string 'wait)
      (proof-prf)
      (message "%s" string)))

  (defun my/coq-mode-setup ()
    "Setup non-customize coq mode stuff."
    (flycheck-mode 0)
    (define-key coq-mode-map (kbd "s-n") #'proof-assert-next-command-interactive)
    (define-key coq-mode-map (kbd "s-<down>") #'proof-assert-next-command-interactive)
    (define-key coq-mode-map (kbd "s-<right>") #'proof-goto-point)
    (define-key coq-mode-map (kbd "s-<up>") #'proof-undo-last-successful-command)
    (define-key coq-mode-map (kbd "s-<left>") #'proof-goto-end-of-locked)
    (define-key coq-mode-map (kbd "s-<end>") #'proof-process-buffer)
    (my/coq-deftoggler coq-toggle-printing-implicit "Printing Implicit" (kbd "C-c i"))
    (my/coq-deftoggler coq-toggle-printing-all "Printing All" (kbd "C-c a"))
    (my/coq-deftoggler coq-toggle-printing-notations "Printing Notations" (kbd "C-c n"))
    (my/coq-deftoggler coq-toggle-printing-universes "Printing Universes" (kbd "C-c u")))

  (add-hook 'coq-mode-hook #'my/coq-mode-setup)

  :preface
  (defmacro my/coq-deftoggler (fn string &optional key)
    "Define function FN toggling option STRING using `my/coq-toggle-option' and bind to KEY."
    `(progn
       (if ,key
           (define-key coq-mode-map ,key (quote ,fn)))

       (defun ,fn ()
         ,(concat "`my/coq-toggle-option' specialised to \""
                  string
                  "\".")
         (interactive)
         (my/coq-toggle-option ,string)))))
#+END_SRC

* Company-Coq
#+BEGIN_SRC emacs-lisp
(use-package company-coq
  :commands (company-coq-mode)
  :defines (company-coq-disabled-features company-coq-live-on-the-edge)
  :init (add-hook 'coq-mode-hook #'company-coq-mode)
  :config
  (setq
   company-coq-disabled-features '(hello)
   company-coq-live-on-the-edge t))
#+END_SRC

* Highlight symbol
Doesn't highlight symbols on current line when hl-line-mode is on,
which is annoying. So I only use it for navigation. I could use
smartscan instead but that doesn't cycle.
#+BEGIN_SRC emacs-lisp
(use-package highlight-symbol
  :commands highlight-symbol-nav-mode
  :config
  (add-hook 'prog-mode-hook #'highlight-symbol-nav-mode)
  (add-hook 'text-mode-hook #'highlight-symbol-nav-mode)
  (add-hook 'org-mode-hook #'highlight-symbol-nav-mode)
  (add-hook 'coq-mode-hook #'highlight-symbol-nav-mode)
  (add-hook 'makefile-mode-hook #'highlight-symbol-nav-mode)
  :bind (("M-n" . highlight-symbol-next) ("M-p" . highlight-symbol-prev)))
#+END_SRC

* AucTex
#+BEGIN_SRC emacs-lisp
(defun Okular-make-url ()
  (concat
   "file://"
   (expand-file-name (concat (TeX-master-file) "." (TeX-output-extension)))
   "#src:"
   (TeX-current-line)
   (expand-file-name (TeX-master-directory))
   "./"
   (TeX-current-file-name-master-relative)))

(use-package tex
  :straight auctex
  :commands TeX-latex-mode
  :config
  (setq
   LaTeX-command "latex -synctex=1")
  (add-hook 'LaTeX-mode-hook
            '(lambda () (add-to-list 'TeX-expand-list
                                '("%u" Okular-make-url))))
  (add-to-list 'TeX-view-program-list
               '("Okular" "okular %u"))
  (add-to-list 'TeX-view-program-selection
               '(output-pdf "Okular")))

(use-package company-bibtex
  :commands company-bibtex
  :config (add-to-list 'company-backends #'company-bibtex))

;; just rely on autoloads for this one
(use-package biblio
  :defer t)
#+END_SRC

* Agda
#+BEGIN_SRC emacs-lisp
(use-package agda2
  :straight nil
  :load-path "/usr/share/emacs/site-lisp/elpa-src/agda2-mode-2.5.3/"
  :mode (("\\.agda\\'" . agda2-mode)))
#+END_SRC

* Docker
#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :mode  (("\\Dockerfile\\'" . dockerfile-mode)))
#+END_SRC

* erc
#+BEGIN_SRC emacs-lisp
(use-package erc
  :straight nil
  :commands erc-tls
  :config
  (setq
   erc-server "irc.freenode.net"
   erc-port 6697
   erc-nick "SkySkimmer"
   erc-password nil
   erc-user-full-name user-full-name
   ;;erc-email-userid "userid"    ; for when ident is not activated
   ;;erc-password ; in secrets
   erc-lurker-hide-list '("JOIN" "PART" "QUIT")
   erc-lurker-threshold-time 3600
   erc-prompt-for-password nil
   erc-autojoin-timing 'ident
   erc-try-new-nick-p nil
   erc-user-full-name "SkySkimmer"
   erc-join-buffer 'window)

  (setq erc-autojoin-channels-alist
        `(("freenode.net" "##hott" "#emacs")
          (,(rx "rizon." (* anything)) "#madokami" "#nyaa-dev")))

  (defun my/erc-reconnect-all ()
    "Reconnect to all erc servers"
    (interactive)
    (let ((buffers (buffer-list)))
      (while buffers
        (let ((buffer (car buffers)))
          (when (erc-server-buffer-p buffer)
            (with-current-buffer buffer
              (erc-server-reconnect)))
          (setq buffers (cdr buffers)))))))

(use-package erc-services
  :straight nil
  :after erc
  :config
  (setq erc-prompt-for-nickserv-password nil)

  ;; from secrets
  (defvar erc-freenode-password)
  (defvar erc-rizon-password)
  (setq erc-nickserv-passwords
        `((freenode (("SkySkimmer" . ,erc-freenode-password)))
          (Rizon (("SkySkimmer" . ,erc-rizon-password)))))

  (erc-services-mode 1))
#+END_SRC

* Systemd
#+BEGIN_SRC emacs-lisp
(use-package systemd
  :defer t)
#+END_SRC

* Dictionary (sdcv)
#+BEGIN_SRC emacs-lisp
(use-package sdcv
  :bind (("C-c d" . sdcv-search-input)
         :map sdcv-mode-map
         ("RET" . sdcv-search-input)))
#+END_SRC

* Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :demand t
  :config
  (projectile-mode)
  (setq projectile-mode-line-prefix " ℘")
  (setq projectile-mode-line-function
        (lambda ()
          (if (or (file-remote-p default-directory) (not (projectile-project-p)))
              projectile-mode-line-prefix
            (format " ℘[%s]" (projectile-project-name)))))
  (setq projectile-switch-project-action 'projectile-vc)

  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
  (define-key projectile-mode-map (kbd "C-c p C-b") #'magit-blame)
  (define-key projectile-mode-map (kbd "C-c p C-l") #'magit-log-buffer-file))

(use-package counsel-projectile
  :after projectile
  :config (counsel-projectile-mode 1)
  ;; Set default action to magit, see
  ;; https://github.com/ericdanan/counsel-projectile/issues/62
  (setcar
   counsel-projectile-switch-project-action
   (1+ (cl-position #'counsel-projectile-switch-project-action-vc
                    (cdr counsel-projectile-switch-project-action)
                    :key #'cadr))))
#+END_SRC

* Comint
#+BEGIN_SRC emacs-lisp
  (setq
   comint-prompt-read-only t)

  (defun my-comint-preoutput-read-only (text)
    (propertize text 'read-only t))

  (add-hook 'comint-preoutput-filter-functions
            'my-comint-preoutput-read-only)
#+END_SRC

* Fish
#+BEGIN_SRC emacs-lisp
(use-package fish-mode
  :defer t)
#+END_SRC

* Hydra
#+BEGIN_SRC emacs-lisp
;; (use-package hydra
;;   :config
;;   (hydra-add-font-lock))
;; (use-package ivy-hydra)
;; (global-set-key
;;  (kbd "<f1>")
;;  (defhydra hydra-help (:color blue)
;;    "Help"
;;    ("c" describe-char "Describe Char")
;;    ("e" view-echo-area-messages "Messages")
;;    ("f" find-function "Find Function")
;;    ("F" describe-function "Describe Function")
;;    ("k" describe-key "Describe Key")
;;    ("K" find-function-on-key "Find Key")
;;    ("m" describe-mode "Describe Modes")
;;    ("v" find-variable "Find Variable")
;;    ("V" describe-variable "Describe Variable")
;;    ("q" nil "Quit")))
#+END_SRC

* Wgrep
#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :defer t)
#+END_SRC

* Python
#+BEGIN_SRC emacs-lisp
(use-package python
  :defer t
  :straight nil
  :commands (python-mode run-python)
  :config
  (setq python-shell-interpreter "python3"))
#+END_SRC

* QML
This is useful for KDE configuration files.
#+BEGIN_SRC emacs-lisp
(use-package qml-mode
  :defer t)
#+END_SRC

* Yaml
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :defer t)
#+END_SRC

* Ending
Diminishing (somewhat bugged)
#+BEGIN_SRC emacs-lisp
(defun my/diminishings ()
  (interactive)
  (diminish 'yas-minor-mode)
  (diminish 'hs-minor-mode)
  (diminish 'holes-mode)
  (diminish 'outline-minor-mode))

(add-hook 'after-init-hook #'my/diminishings)
(eval-after-load 'org-indent '(diminish 'org-indent-mode))
(eval-after-load 'company-coq '(my/diminishings))
#+END_SRC

Reset dired-omit-extensions after we added stuff that should got into it.
#+BEGIN_SRC emacs-lisp
(setq dired-omit-extensions
      (append
       completion-ignored-extensions
       dired-latex-unclean-extensions
       dired-bibtex-unclean-extensions
       dired-texinfo-unclean-extensions))
#+END_SRC
