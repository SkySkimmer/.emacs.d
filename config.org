#+STARTUP: overview

* Secrets
#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/secrets" nil nil)
#+END_SRC

* Backups
#+BEGIN_SRC emacs-lisp
  (setq
   backup-directory-alist '(("." . "~/.emacs.d/backups"))
   delete-old-versions -1
   version-control t
   vc-make-backup-files t
   backup-by-copying t)
#+END_SRC
This bit is for the # anti-crash files
#+BEGIN_SRC emacs-lisp
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC

* History
This is mostly minibuffer history. Not sure it works with counsel, we shall see.
#+BEGIN_SRC emacs-lisp
  (require 'savehist)
  (savehist-mode 1)
  (setq savehist-file "~/.emacs.d/savehist")
  (setq history-length t)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history t)
  (setq savehist-additional-variables
        '(kill-ring
          search-ring
          regexp-search-ring))
#+END_SRC

* interface tweaks
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (global-set-key (kbd "<f5>") 'revert-buffer)
  (defalias 'list-buffers 'ibuffer)
  (show-paren-mode 1)
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
  (delete-selection-mode 1); delete selected region on typing
  (line-number-mode 1)
  (column-number-mode 1)
  (setq-default indent-tabs-mode nil)
  (setq
   inhibit-startup-message t
   require-final-newline t
   diff-switches "-u"; unified diffs
   sentence-end-double-space nil
   scroll-error-top-bottom t
   read-quoted-char-radix 16
   apropos-do-all t
   browse-url-browser-function 'eww-browse-url
   recentf-max-saved-items 100
   recenter-positions '(top middle bottom)
   use-dialog-box nil
   disabled-command-function nil
   compilation-scroll-output 'first-error)

;; thanks http://pragmaticemacs.com/emacs/cycle-spacing/
(global-set-key (kbd "M-SPC") 'cycle-spacing)
#+END_SRC

** Dash fontlock
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'dash
  (dash-enable-font-lock))
#+END_SRC

** Dired
#+BEGIN_SRC emacs-lisp
  (require 'dired)
  (setq
   dired-ls-F-marks-symlinks t
   dired-listing-switches "-alF --group-directories-first")
#+END_SRC

** Clipboard integration
   #+BEGIN_SRC emacs-lisp
     (setq select-enable-clipboard t)
     ;; Treat clipboard input as UTF-8 string first; compound text next, etc.
     (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
     (setq save-interprogram-paste-before-kill t)
     (setq kill-do-not-save-duplicates t)
   #+END_SRC

** highlight current line
   #+BEGIN_SRC emacs-lisp
     (require 'hl-line)
     (global-hl-line-mode t)
     (set-face-background hl-line-face "LightCyan2")
   #+END_SRC

** Scroll
   #+BEGIN_SRC emacs-lisp
     (setq
      mouse-wheel-scroll-amount '(1 ((shift) . 1))
      mouse-wheel-progressive-speed nil)

     (defun window-half-height ()
       (max 1 (/ (1- (window-height (selected-window))) 2)))

     (defun reset-next-screen-context-lines ()
       "Set `next-screen-context-lines' to screen height / 2"
       (setq next-screen-context-lines (window-half-height)))

     (defadvice scroll-up-command (before scroll-up-half-screen activate)
       "Set `next-screen-context-lines' to screen height / 2"
       (reset-next-screen-context-lines))
     (defadvice scroll-down-command (before scroll-down-half-screen activate)
       "Set `next-screen-context-lines' to screen height / 2"
       (reset-next-screen-context-lines))
   #+END_SRC

** Move to beginning of line
   #+BEGIN_SRC emacs-lisp
     (defun my/smarter-move-beginning-of-line (arg)
       "Move point back to indentation of beginning of line.

     Move point to the first non-whitespace character on this line.
     If point is already there, move to the beginning of the line.
     Effectively toggle between the first non-whitespace character and
     the beginning of the line.

     If ARG is not nil or 1, move forward ARG - 1 lines first.  If
     point reaches the beginning or end of the buffer, stop there."
       (interactive "^p")
       (setq arg (or arg 1))

       ;; Move lines first
       (when (/= arg 1)
         (let ((line-move-visual nil))
           (forward-line (1- arg))))

       (let ((orig-point (point)))
         (back-to-indentation)
         (when (= orig-point (point))
           (move-beginning-of-line 1))))

     ;; remap C-a to `smarter-move-beginning-of-line'
     (global-set-key [remap move-beginning-of-line]
                     'my/smarter-move-beginning-of-line)
   #+END_SRC

** Subword mode
#+BEGIN_SRC emacs-lisp
;(global-subword-mode 1)
(diminish 'subword-mode)
#+END_SRC

** Frame title
Note that the "〖〗" characters have no space before/after them.

Print default directory according to major mode based on [[https://github.com/jbms/jmswm/blob/19f11ff1f081c07468b149998d851a2b7b1d54cd/config/emacs.example.el][jbms@github/jmswm]].
#+BEGIN_SRC emacs-lisp
  (setq major-modes-with-meaningful-directory
        '(magit-log-mode
          magit-status-mode
          dired-mode
          eshell-mode))

  (defun default-directory-meaningful-p ()
    "Figure out if the default directory of the current buffer
  is meaningful according to `major-modes-with-meaningful-directory'"
    (memq major-mode major-modes-with-meaningful-directory))

  (defun help-what-about ()
    "Returns nil if called in non help-mode derived buffer.
  Otherwise guesses what the help buffer is about.
  If it succeeds the guess is returned as a string. Otherwise returns nil.

  Heuristics:
  If the buffer starts with a known symbol (i.e. in `obarray') that's our result.
  This may return the wrong thing: imagine a mode where `t t' runs `foo', we will
  think `describe-key' is talking about `t' alone.
  If someone defines `Enabled' we will be similarly confused after `describe-mode', etc."
    (if (derived-mode-p 'help-mode)
        (let ((described-thing
               ;; (current-word t ...) protects us against things
               ;; like describe-char which start with spaces
               (save-excursion (progn (goto-char (point-min)) (current-word t nil)))))
          (if (or
               (intern-soft described-thing)
               ;; Special case since  (intern-soft "nil") ==> nil
               (string-equal described-thing "nil"))
              described-thing
            nil))))

  (defun frame-title-mode-bonus ()
    "If current buffer is associated with a file, return that file's name.
  Otherwise if `default-directory-meaningful-p' return the default directory.
  In both cases paths are bracketed with \"〖〗\" and processed by `abbreviate-file-name'.
  If no path is meaningful return a space."
    (if (buffer-file-name)
        (format "〖%s〗" (abbreviate-file-name (buffer-file-name)))
      (if (default-directory-meaningful-p)
          (format "〖%s〗" (abbreviate-file-name default-directory))
        (if-let ((described-thing (help-what-about)))
            (format "〖%s〗" described-thing)
          " "))))

  (setq frame-title-format
        '((:eval (if (and (buffer-modified-p) (not buffer-read-only)) "(!) " ""))
          "%b"
          (:eval (frame-title-mode-bonus))
          "— Emacs"))
#+END_SRC

* Emacs source
#+BEGIN_SRC emacs-lisp
(setq find-function-C-source-directory "/home/gaetan/dev/emacs/src/")
#+END_SRC

* Rainbow mode
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode)
#+END_SRC

* Avy and linum configuration
Replace =goto-line= with =avy-goto-line= with temporary enabling of linum mode.
Linum mode is also made to look nicer.

Note that jumping to a line by its number is still possible with avy.

Fist make linum pretty
#+BEGIN_SRC emacs-lisp
(require 'linum)
(set-face-attribute 'linum nil
                    :background (face-attribute 'default :background)
                    :foreground (face-attribute 'font-lock-comment-face :foreground))
(defface linum-current-line-face
  `((t :background "gray30" :foreground "gold"))
  "Face for the currently active Line number")
(defvar my-linum-current-line-number 0)
(defun get-linum-format-string ()
  (setq-local my-linum-format-string
              (let ((w (length (number-to-string
                                (count-lines (point-min) (point-max))))))
                (concat " %" (number-to-string w) "d "))))
(add-hook 'linum-before-numbering-hook 'get-linum-format-string)
(defun my-linum-format (line-number)
  (propertize (format my-linum-format-string line-number) 'face
              (if (eq line-number my-linum-current-line-number)
                  'linum-current-line-face
                'linum)))
(setq linum-format 'my-linum-format)
(defadvice linum-update (around my-linum-update activate)
  (let ((my-linum-current-line-number (line-number-at-pos)))
    ad-do-it))
#+END_SRC

Then setup avy
#+BEGIN_SRC emacs-lisp
(use-package avy)

;; based on joshwnj and magnars https://gist.github.com/joshwnj/3292750
(defun avy-goto-line-with-feedback ()
  "Show line numbers temporarily, while prompting for the line number input"
  (interactive)
  (let ((line-numbers-off-p (not linum-mode)))
    (unwind-protect
        (progn (when line-numbers-off-p
                 (linum-mode 1))
               (call-interactively 'avy-goto-line))
      (when line-numbers-off-p
        (linum-mode -1)))))
(global-set-key [remap goto-line] 'avy-goto-line-with-feedback)
#+END_SRC

* Save place in files
#+BEGIN_SRC emacs-lisp
(require 'saveplace)
(setq save-place-file "~/.emacs.d/saveplace")
(save-place-mode t)
#+END_SRC

* Unicode
#+BEGIN_SRC emacs-lisp
(set-charset-priority 'unicode)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix))
#+END_SRC

* Immortal *scratch*
#+BEGIN_SRC emacs-lisp
(defadvice kill-buffer (around kill-buffer-around-advice activate)
  (let ((buffer-to-kill (ad-get-arg 0)))
    (if (equal buffer-to-kill "*scratch*")
        (bury-buffer buffer-to-kill)
      ad-do-it)))
#+END_SRC

* Prettify symbols
#+BEGIN_SRC emacs-lisp
  (defun prettify-lisp-additions ()
    (push '("lambda" . ?λ) prettify-symbols-alist))

  (add-hook 'emacs-lisp-mode-hook
            'prettify-lisp-additions)

  (defun prettify-ocaml-additions ()
    (push '("->" . ?→) prettify-symbols-alist))
  (add-hook 'tuareg-mode-hook
            'prettify-ocaml-additions)

  (global-prettify-symbols-mode 1)
#+END_SRC

* try
#+BEGIN_SRC emacs-lisp
(use-package try)
#+END_SRC

* which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish which-key-mode
    :config
    (which-key-mode))
#+END_SRC

* org mode
#+BEGIN_SRC emacs-lisp
(require 'org)
(setq
 org-catch-invisible-edits 'error
 org-return-follows-link t
 org-startup-indented t
 org-src-preserve-indentation t
 org-src-fontify-natively t
 org-src-tab-acts-natively t
 org-ellipsis " ▼"
 org-cycle-separator-lines 1)

(use-package org-bullets
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

* Window switching (Ace window)
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :init
  (global-set-key [remap other-window] 'ace-window)
  (custom-set-faces
   '(aw-leading-char-face
     ((t (:inherit ace-jump-face-foreground :height 3.0)))))
  :config
  (setq aw-scope 'frame))
#+END_SRC

* Swiper
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :bind
    (("M-y" . counsel-yank-pop)
     :map ivy-minibuffer-map
     ("M-y" . ivy-next-line)))

  (use-package ivy
    :ensure t
    :diminish (ivy-mode)
    :bind (("C-x b" . ivy-switch-buffer))
    :config
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-display-style 'fancy))

  (use-package swiper
    :ensure try
    :bind (("C-s" . swiper)
           ("C-r" . swiper)
           ("C-c C-r" . ivy-resume)
           ("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file))
    :config
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-display-style 'fancy)
    (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
    (setq counsel-find-file-ignore-regexp
          (rx (or
               (: "~" eol)
               (: bol ".")
               (: ".ml" (? "i") ".d" eol)
               (: ".mllib.d" eol)
               (: ".cm" (char "iotx") eol)
               (: ".cmti" eol)
               (: ".o" eol)
               (: ".glob" eol)
               (: ".vo" eol)))))
#+END_SRC

* Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :diminish " ℂ"
  :config
  (global-company-mode))
#+END_SRC

* Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :config
  (global-flycheck-mode)
  (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc coq)))
#+END_SRC

* Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :config
    (setq magit-diff-refine-hunk 'all)
    (setq magit-log-margin '(t "%Y-%m-%d %H:%M" magit-log-margin-width t 18)))
#+END_SRC

* OCaml
#+BEGIN_SRC emacs-lisp
(use-package flycheck-ocaml
  :config
  (setq tuareg-indent-align-with-first-arg nil)
  (with-eval-after-load 'merlin
    ;; Disable Merlin's own error checking
    (setq merlin-error-after-save nil)
    (setq merlin-command "/home/gaetan/.opam/system/bin/ocamlmerlin")
    ;; Enable Flycheck checker
    (flycheck-ocaml-setup))

  (add-hook 'tuareg-mode-hook 'merlin-mode))

(use-package tuareg
  :diminish merlin-mode)

(defun debug-coq-sender (input)
  (insert input)
  (comint-send-input))

(defun debug-coq (coqdir)
  "Call ocamldebug for coqtop with correct arguments."
  (interactive "DCoq root directory: ")
  (let ((ocamldebug-command-name "../dev/ocamldebug-coq"))
    (ocamldebug (concat coqdir "bin/coqtop.byte"))
    (debug-coq-sender "source db")))
#+END_SRC

* Markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode)
#+END_SRC

* Whitespace
  #+BEGIN_SRC emacs-lisp
    (setq show-trailing-whitespace t)
  #+END_SRC

** ws-butler (unobtrusive whitespace remover)
   #+BEGIN_SRC emacs-lisp
     (use-package ws-butler
       :diminish ws-butler-mode
       :init
       (add-hook 'prog-mode-hook #'ws-butler-mode)
       (add-hook 'org-mode-hook #'ws-butler-mode)
       (add-hook 'text-mode-hook #'ws-butler-mode)
       (add-hook 'proof-mode-hook #'ws-butler-mode))
   #+END_SRC

* nv-delete-back
#+BEGIN_SRC emacs-lisp
(use-package nv-delete-back
  :bind (("C-<backspace>" . nv-delete-back-all)
         ("M-<backspace>" . nv-delete-back)))
#+END_SRC

* Semantic region
#+BEGIN_SRC emacs-lisp
  ; expand the marked region in semantic increments (negative prefix to reduce region)
  (use-package expand-region
    :config
    (global-set-key (kbd "C-=") 'er/expand-region))
#+END_SRC

* Narrowing
#+BEGIN_SRC emacs-lisp
  (defun narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or
  defun, whichever applies first. Narrowing to
  org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer
  is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning)
                             (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing
           ;; command. Remove this first conditional if
           ;; you don't want it.
           (cond ((ignore-errors (org-edit-src-code) t)
                  (delete-other-windows))
                 ((ignore-errors (org-narrow-to-block) t))
                 (t (org-narrow-to-subtree))))
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          (t (narrow-to-defun))))

  ;; This line actually replaces Emacs' entire narrowing
  ;; keymap, that's how much I like this command. Only
  ;; copy it if that's what you want.
  (define-key ctl-x-map "n" #'narrow-or-widen-dwim)
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (define-key LaTeX-mode-map "\C-xn"
                nil)))
#+END_SRC

* Undo tree
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :config
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-diff t)
    (setq undo-tree-visualizer-timestamps t))
#+END_SRC

* Proof General
#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/lisp/proofgeneral/generic/proof-site")

(setq
 proof-prog-name-ask t
 proof-follow-mode 'followdown
 proof-sticky-errors t)

(require 'proof-utils) ; it complains about the use of proof-escape-keymap-doc otherwise

(defun my/coq-test-option (string)
  "Ask Coq if option STRING is set."
  (let ((res (company-coq-ask-prover (concat "Test " string "."))))
    (cond
     ((string-match-p (rx "off" eol) res) nil)
     ((string-match-p (rx "on" eol) res) t)
     (t (error "Bad result in coq-test-option: %s" res)))))

(defun my/coq-toggle-option (string)
  "Toggle option STRING according to the result of `my/coq-test-option'."
  (interactive "M")
  (let ((string (if (my/coq-test-option string)
                    (concat "Unset " string ".")
                  (concat "Set " string "."))))
    (proof-shell-invisible-command string 'wait)
    (proof-prf)
    (message "%s" string)))

(defmacro my/coq-deftoggler (fn string &optional key)
  "Define function FN toggling option STRING using `my/coq-toggle-option' and bind to KEY."
  `(progn
     (if ,key
         (define-key coq-mode-map ,key (quote ,fn)))

     (defun ,fn ()
       ,(concat "`my/coq-toggle-option' specialised to \""
                (proof-escape-keymap-doc string)
                "\".")
       (interactive)
       (my/coq-toggle-option ,string))))

(defun my/coq-mode-setup ()
  "Setup non-customize coq mode stuff."
  (flycheck-mode 0)
  (define-key coq-mode-map (kbd "s-n") 'proof-assert-next-command-interactive)
  (define-key coq-mode-map (kbd "s-<down>") 'proof-assert-next-command-interactive)
  (define-key coq-mode-map (kbd "s-<right>") 'proof-goto-point)
  (define-key coq-mode-map (kbd "s-<up>") 'proof-undo-last-successful-command)
  (define-key coq-mode-map (kbd "s-<left>") 'proof-goto-end-of-locked)
  (my/coq-deftoggler coq-toggle-printing-implicit "Printing Implicit" (kbd "C-c i"))
  (my/coq-deftoggler coq-toggle-printing-all "Printing All" (kbd "C-c a"))
  (my/coq-deftoggler coq-toggle-printing-notations "Printing Notations" (kbd "C-c n"))
  (my/coq-deftoggler coq-toggle-printing-universes "Printing Universes" (kbd "C-c u")))
(add-hook 'coq-mode-hook #'my/coq-mode-setup)
#+END_SRC

* Company-Coq
#+BEGIN_SRC emacs-lisp
(use-package company-coq
  :config
  (setq
   company-coq-disabled-features '(hello)
   company-coq-live-on-the-edge t)
  (add-hook 'coq-mode-hook #'company-coq-mode))
#+END_SRC

* Highlight symbol
Doesn't highlight symbols on current line when hl-line-mode is on, which is annoying. So I only use it for navigation.
I could use smartscan instead but that doesn't cycle.
#+BEGIN_SRC emacs-lisp
  (use-package highlight-symbol
    :init
    (add-hook 'prog-mode-hook #'highlight-symbol-nav-mode)
    (add-hook 'text-mode-hook #'highlight-symbol-nav-mode)
    (add-hook 'org-mode-hook #'highlight-symbol-nav-mode))
#+END_SRC

* AucTex
#+BEGIN_SRC emacs-lisp
  (defun Okular-make-url ()
    (concat
     "file://"
     (expand-file-name (funcall file (TeX-output-extension) t)
                       (file-name-directory (TeX-master-file)))
     "#src:"
     (TeX-current-line)
     (expand-file-name (TeX-master-directory))
     "./"
     (TeX-current-file-name-master-relative)))

  (use-package tex
    :ensure auctex
    :config
    (setq
     LaTeX-command "latex -synctex=1")
    (add-hook 'LaTeX-mode-hook
              '(lambda () (add-to-list 'TeX-expand-list
                                  '("%u" Okular-make-url))))
    (add-to-list 'TeX-command-list
                 '("Okular" "okular %u"
                   TeX-run-discard-or-function nil t :help "View file")))
#+END_SRC

* erc
#+BEGIN_SRC emacs-lisp
  (setq erc-server "irc.freenode.net"
        erc-port 6697
        erc-nick "SkySkimmer"
        erc-user-full-name user-full-name
        ;;erc-email-userid "userid"    ; for when ident is not activated
        ;;erc-password ; in secrets
        erc-lurker-hide-list '("JOIN" "PART" "QUIT")
        erc-lurker-threshold-time 3600)
#+END_SRC

* Systemd
#+BEGIN_SRC emacs-lisp
  (use-package systemd)
#+END_SRC

* Dictionary (sdcv)
#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/lisp/emacs-sdcv/sdcv-mode" nil t)
(global-set-key (kbd "C-c d") 'sdcv-search)
#+END_SRC

* Projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :config
    (projectile-global-mode)
    (setq projectile-mode-line
          '(:eval
            (if (or (file-remote-p default-directory) (not (projectile-project-p)))
                " ℘"
              (format " ℘[%s]" (projectile-project-name))))))
  (use-package counsel-projectile
    :config (counsel-projectile-on))
#+END_SRC

* Comint
#+BEGIN_SRC emacs-lisp
  (setq
   comint-prompt-read-only t)

  (defun my-comint-preoutput-read-only (text)
    (propertize text 'read-only t))

  (add-hook 'comint-preoutput-filter-functions
            'my-comint-preoutput-read-only)
#+END_SRC

* Hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra)
(use-package ivy-hydra)
(global-set-key
 (kbd "<f1>")
 (defhydra hydra-help (:color blue)
   "Help"
   ("a" helm-apropos "Apropos")
   ("c" describe-char "Describe Char")
   ("f" find-function "Find Function")
   ("F" describe-function "Describe Function")
   ("k" describe-key "Describe Key")
   ("K" find-function-on-key "Find Key")
   ("m" describe-mode "Describe Modes")
   ("v" find-variable "Find Variable")
   ("V" describe-variable "Describe Variable")))
#+END_SRC

* Wgrep
#+BEGIN_SRC emacs-lisp
(use-package wgrep)
(use-package wgrep-ag)
#+END_SRC

* Diminishing
#+BEGIN_SRC emacs-lisp
(defun my/diminishings ()
  (diminish 'yas-minor-mode)
  (diminish 'hs-minor-mode)
  (diminish 'holes-mode)
  (diminish 'outline-minor-mode))

(add-hook 'after-init-hook #'my/diminishings)
(eval-after-load 'org-indent '(diminish 'org-indent-mode))
#+END_SRC
